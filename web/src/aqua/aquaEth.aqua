data Result:
    success: bool
    reason: string
    code: u32
    message: string

data ResultString:
    info: Result
    data: string

-- Same as result string but the user knows to parse JSON string
data ResultJSONString:
    info: Result
    data: string

data ResultAddresses:
    info: Result
    data: []string

data ResultU32:
    info: Result
    data: u32

data JSONPacket:
    type: string
    data: string

data Currency:
    name: string
    symbol: string
    decimals: u32 

data Chain:
    name: string
    chainId: u32
    shortName: string
    network: string
    networkId: u32
    currency: Currency

data ResultChain:
    info: Result
    data: Chain

data TransactionRequest:
    to: string
    from: string
    nonce: u32
    data: string
    value: string
    gasLimit: string
    gasPrice: string
    maxFeePerGas: string
    maxPriorityFeePerGas: string
    chainId: u32
    transactionRequest: u32

data TransactionResponse:
    blockNumber: u32
    blockHash: string
    timestamp: u32
    confirmation: u32
    raw: string
    type: u32

alias BigNumber: string 

data TransactionReceipt:
    to: string
    from: string
    contractAddress: string
    transactionIndex: u32
    type: u32
    gasUsed: BigNumber
    transactionHash: string
    status: bool 

data ResultTransaction:
    info: Result
    data: TransactionResponse

func identityResultString(val: ResultString) -> ResultString:
    <- val 

func identityResultChain(val: ResultChain) -> ResultChain:
    <- val 

service Ethereum("ethereum"):
    -- Methods that execute on the remote client (The one with MetaMask)
    requestAccounts() -> ResultAddresses
    getConnectedChainInfo() -> ResultChain
    getChainInfo(chainId: u32) -> ResultChain
    getBalance(address: string) -> ResultString
    getBlockNumber() -> ResultString

    -- Wei to Eth
    formatEther(amount: string) -> ResultString
    -- Eth to Wei
    parseEther(amount: string) -> ResultString
    
    sendTransaction(transactionRequest: TransactionRequest) -> ResultTransaction

    -- Methods to register a listener for window.ethereum events on the
    -- local node
    registerListenerNode(listenerPeerId: string, listenerRelayId: string)
    receiveData(packet: JSONPacket)

func requestAccounts(peerId: string, relayId: string) -> ResultAddresses:
    on peerId via relayId:
        res <- Ethereum.requestAccounts()
    <- res
    
func getChainInfo(peerId: string, relayId: string) -> ResultChain:
    on peerId via relayId:
        res <- Ethereum.getConnectedChainInfo()
    <- res

func registerListenerNode(peerId: string, relayId: string, listenerPeerId: string, listenerRelayId: string):
    on peerId via relayId:
        Ethereum.registerListenerNode(listenerPeerId, listenerRelayId)
    
func listenerNodeCallback(peerId: string, relayId: string, jsonPacket: JSONPacket):
    on peerId via relayId:
        Ethereum.receiveData(jsonPacket)

func getBalance(peerId: string, relayId: string, address: string) -> ResultString:
    resBox: *ResultString

    on peerId via relayId:
        blockRes <- Ethereum.getBalance(address)
        if blockRes.info.success:
            resBox <- Ethereum.formatEther(blockRes.data)
        else:
            resBox <- identityResultString(blockRes)
            
    <- resBox! 

func getBlockNumber(peerId: string, relayId: string) -> ResultString:
    on peerId via relayId:
        res <- Ethereum.getBlockNumber()
    <- res

func formatEther(peerId: string, relayId: string, amount: string) -> ResultString:
    on peerId via relayId:
        res <- Ethereum.formatEther(amount)
    <- res

func parseEther(peerId: string, relayId: string, amount: string) -> ResultString:
    on peerId via relayId:
        res <- Ethereum.parseEther(amount)
    <- res

func sendTransaction(peerId: string, relayId: string, transactionRequest: TransactionRequest) -> ResultTransaction:
    on peerId via relayId:
        res <- Ethereum.sendTransaction(transactionRequest)
    <- res